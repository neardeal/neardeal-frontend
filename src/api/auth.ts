/**
 * Generated by orval v8.0.2 üç∫
 * Do not edit manually.
 * LOOKY API Server
 * API Î™ÖÏÑ∏ÏÑú
 * OpenAPI spec version: v1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CheckUsernameAvailabilityParams,
  CompleteSocialSignupParams,
  CouncilSignupRequest,
  LoginRequest,
  OwnerSignupRequest,
  SendEmailCodeRequest,
  StudentSignupRequest,
  VerifyEmailCodeRequest,
  WithdrawRequest
} from './generated.schemas';

import { customFetch } from './mutator';



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * ÌïôÏÉù ÌöåÏõêÏùÑ Îì±Î°ùÌï©ÎãàÎã§.
 * @summary [ÌïôÏÉù] ÌïôÏÉù ÌöåÏõêÍ∞ÄÏûÖ
 */
export type signupStudentResponse200 = {
  data: Blob
  status: 200
}
    
export type signupStudentResponseSuccess = (signupStudentResponse200) & {
  headers: Headers;
};
;

export type signupStudentResponse = (signupStudentResponseSuccess)

export const getSignupStudentUrl = () => {


  

  return `/api/auth/signup/student`
}

export const signupStudent = async (studentSignupRequest: StudentSignupRequest, options?: RequestInit): Promise<signupStudentResponse> => {
  
  return customFetch<signupStudentResponse>(getSignupStudentUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      studentSignupRequest,)
  }
);}




export const getSignupStudentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupStudent>>, TError,{data: StudentSignupRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof signupStudent>>, TError,{data: StudentSignupRequest}, TContext> => {

const mutationKey = ['signupStudent'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signupStudent>>, {data: StudentSignupRequest}> = (props) => {
          const {data} = props ?? {};

          return  signupStudent(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SignupStudentMutationResult = NonNullable<Awaited<ReturnType<typeof signupStudent>>>
    export type SignupStudentMutationBody = StudentSignupRequest
    export type SignupStudentMutationError = unknown

    /**
 * @summary [ÌïôÏÉù] ÌïôÏÉù ÌöåÏõêÍ∞ÄÏûÖ
 */
export const useSignupStudent = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupStudent>>, TError,{data: StudentSignupRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof signupStudent>>,
        TError,
        {data: StudentSignupRequest},
        TContext
      > => {
      return useMutation(getSignupStudentMutationOptions(options), queryClient);
    }
    /**
 * Ï†êÏ£º ÌöåÏõêÏùÑ Îì±Î°ùÌï©ÎãàÎã§.
 * @summary [Ï†êÏ£º] Ï†êÏ£º ÌöåÏõêÍ∞ÄÏûÖ
 */
export type signupOwnerResponse200 = {
  data: Blob
  status: 200
}
    
export type signupOwnerResponseSuccess = (signupOwnerResponse200) & {
  headers: Headers;
};
;

export type signupOwnerResponse = (signupOwnerResponseSuccess)

export const getSignupOwnerUrl = () => {


  

  return `/api/auth/signup/owner`
}

export const signupOwner = async (ownerSignupRequest: OwnerSignupRequest, options?: RequestInit): Promise<signupOwnerResponse> => {
  
  return customFetch<signupOwnerResponse>(getSignupOwnerUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ownerSignupRequest,)
  }
);}




export const getSignupOwnerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupOwner>>, TError,{data: OwnerSignupRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof signupOwner>>, TError,{data: OwnerSignupRequest}, TContext> => {

const mutationKey = ['signupOwner'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signupOwner>>, {data: OwnerSignupRequest}> = (props) => {
          const {data} = props ?? {};

          return  signupOwner(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SignupOwnerMutationResult = NonNullable<Awaited<ReturnType<typeof signupOwner>>>
    export type SignupOwnerMutationBody = OwnerSignupRequest
    export type SignupOwnerMutationError = unknown

    /**
 * @summary [Ï†êÏ£º] Ï†êÏ£º ÌöåÏõêÍ∞ÄÏûÖ
 */
export const useSignupOwner = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupOwner>>, TError,{data: OwnerSignupRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof signupOwner>>,
        TError,
        {data: OwnerSignupRequest},
        TContext
      > => {
      return useMutation(getSignupOwnerMutationOptions(options), queryClient);
    }
    /**
 * ÌïôÏÉùÌöå ÌöåÏõêÏùÑ Îì±Î°ùÌï©ÎãàÎã§.
 * @summary [ÌïôÏÉùÌöå] ÌïôÏÉùÌöå ÌöåÏõêÍ∞ÄÏûÖ
 */
export type signupcouncilResponse200 = {
  data: Blob
  status: 200
}
    
export type signupcouncilResponseSuccess = (signupcouncilResponse200) & {
  headers: Headers;
};
;

export type signupcouncilResponse = (signupcouncilResponseSuccess)

export const getSignupcouncilUrl = () => {


  

  return `/api/auth/signup/council`
}

export const signupcouncil = async (councilSignupRequest: CouncilSignupRequest, options?: RequestInit): Promise<signupcouncilResponse> => {
  
  return customFetch<signupcouncilResponse>(getSignupcouncilUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      councilSignupRequest,)
  }
);}




export const getSignupcouncilMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupcouncil>>, TError,{data: CouncilSignupRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof signupcouncil>>, TError,{data: CouncilSignupRequest}, TContext> => {

const mutationKey = ['signupcouncil'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signupcouncil>>, {data: CouncilSignupRequest}> = (props) => {
          const {data} = props ?? {};

          return  signupcouncil(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SignupcouncilMutationResult = NonNullable<Awaited<ReturnType<typeof signupcouncil>>>
    export type SignupcouncilMutationBody = CouncilSignupRequest
    export type SignupcouncilMutationError = unknown

    /**
 * @summary [ÌïôÏÉùÌöå] ÌïôÏÉùÌöå ÌöåÏõêÍ∞ÄÏûÖ
 */
export const useSignupcouncil = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupcouncil>>, TError,{data: CouncilSignupRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof signupcouncil>>,
        TError,
        {data: CouncilSignupRequest},
        TContext
      > => {
      return useMutation(getSignupcouncilMutationOptions(options), queryClient);
    }
    /**
 * RefreshTokenÏúºÎ°ú AccessTokenÏùÑ Í∞±Ïã†Ìï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÌÜ†ÌÅ∞ Í∞±Ïã†
 */
export type refreshResponse200 = {
  data: Blob
  status: 200
}

export type refreshResponse401 = {
  data: Blob
  status: 401
}

export type refreshResponse404 = {
  data: Blob
  status: 404
}
    
export type refreshResponseSuccess = (refreshResponse200) & {
  headers: Headers;
};
export type refreshResponseError = (refreshResponse401 | refreshResponse404) & {
  headers: Headers;
};

export type refreshResponse = (refreshResponseSuccess | refreshResponseError)

export const getRefreshUrl = () => {


  

  return `/api/auth/refresh`
}

export const refresh = async ( options?: RequestInit): Promise<refreshResponse> => {
  
  return customFetch<refreshResponse>(getRefreshUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getRefreshMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refresh>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof refresh>>, TError,void, TContext> => {

const mutationKey = ['refresh'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refresh>>, void> = () => {
          

          return  refresh(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>
    
    export type RefreshMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] ÌÜ†ÌÅ∞ Í∞±Ïã†
 */
export const useRefresh = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refresh>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refresh>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getRefreshMutationOptions(options), queryClient);
    }
    /**
 * ÏÇ¨Ïö©ÏûêÎ•º Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨Ìï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] Î°úÍ∑∏ÏïÑÏõÉ
 */
export type logoutResponse200 = {
  data: Blob
  status: 200
}
    
export type logoutResponseSuccess = (logoutResponse200) & {
  headers: Headers;
};
;

export type logoutResponse = (logoutResponseSuccess)

export const getLogoutUrl = () => {


  

  return `/api/auth/logout`
}

export const logout = async ( options?: RequestInit): Promise<logoutResponse> => {
  
  return customFetch<logoutResponse>(getLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = unknown

    /**
 * @summary [Í≥µÌÜµ] Î°úÍ∑∏ÏïÑÏõÉ
 */
export const useLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getLogoutMutationOptions(options), queryClient);
    }
    /**
 * ÏïÑÏù¥ÎîîÏôÄ ÎπÑÎ∞ÄÎ≤àÌò∏Î°ú Î°úÍ∑∏Ïù∏Ìï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] Î°úÍ∑∏Ïù∏
 */
export type loginResponse200 = {
  data: Blob
  status: 200
}

export type loginResponse400 = {
  data: Blob
  status: 400
}

export type loginResponse401 = {
  data: Blob
  status: 401
}
    
export type loginResponseSuccess = (loginResponse200) & {
  headers: Headers;
};
export type loginResponseError = (loginResponse400 | loginResponse401) & {
  headers: Headers;
};

export type loginResponse = (loginResponseSuccess | loginResponseError)

export const getLoginUrl = () => {


  

  return `/api/auth/login`
}

export const login = async (loginRequest: LoginRequest, options?: RequestInit): Promise<loginResponse> => {
  
  return customFetch<loginResponse>(getLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginRequest,)
  }
);}




export const getLoginMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] Î°úÍ∑∏Ïù∏
 */
export const useLogin = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {
      return useMutation(getLoginMutationOptions(options), queryClient);
    }
    /**
 * Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏΩîÎìúÎ•º Í≤ÄÏ¶ùÌï©ÎãàÎã§. (true: Í≤ÄÏ¶ù (ÏùºÏπò) ÏôÑÎ£å, false: Í≤ÄÏ¶ù Ïã§Ìå® (ÏΩîÎìú Î∂àÏùºÏπò Î∞è Ïù¥ÎØ∏ Îì±Î°ùÎêú Ïù¥Î©îÏùº)
 * @summary [ÌïôÏÉù] ÌïôÍµê Ïù¥Î©îÏùº Ïù∏Ï¶ù ÌôïÏù∏
 */
export type verifyResponse200 = {
  data: Blob
  status: 200
}
    
export type verifyResponseSuccess = (verifyResponse200) & {
  headers: Headers;
};
;

export type verifyResponse = (verifyResponseSuccess)

export const getVerifyUrl = () => {


  

  return `/api/auth/email/verify`
}

export const verify = async (verifyEmailCodeRequest: VerifyEmailCodeRequest, options?: RequestInit): Promise<verifyResponse> => {
  
  return customFetch<verifyResponse>(getVerifyUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      verifyEmailCodeRequest,)
  }
);}




export const getVerifyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verify>>, TError,{data: VerifyEmailCodeRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof verify>>, TError,{data: VerifyEmailCodeRequest}, TContext> => {

const mutationKey = ['verify'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verify>>, {data: VerifyEmailCodeRequest}> = (props) => {
          const {data} = props ?? {};

          return  verify(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyMutationResult = NonNullable<Awaited<ReturnType<typeof verify>>>
    export type VerifyMutationBody = VerifyEmailCodeRequest
    export type VerifyMutationError = unknown

    /**
 * @summary [ÌïôÏÉù] ÌïôÍµê Ïù¥Î©îÏùº Ïù∏Ï¶ù ÌôïÏù∏
 */
export const useVerify = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verify>>, TError,{data: VerifyEmailCodeRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verify>>,
        TError,
        {data: VerifyEmailCodeRequest},
        TContext
      > => {
      return useMutation(getVerifyMutationOptions(options), queryClient);
    }
    /**
 * Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏΩîÎìúÎ•º Ï†ÑÏÜ°Ìï©ÎãàÎã§.
 * @summary [ÌïôÏÉù] ÌïôÍµê Ïù¥Î©îÏùº Ïù∏Ï¶ù Î∞úÏÜ°
 */
export type sendResponse200 = {
  data: Blob
  status: 200
}
    
export type sendResponseSuccess = (sendResponse200) & {
  headers: Headers;
};
;

export type sendResponse = (sendResponseSuccess)

export const getSendUrl = () => {


  

  return `/api/auth/email/send`
}

export const send = async (sendEmailCodeRequest: SendEmailCodeRequest, options?: RequestInit): Promise<sendResponse> => {
  
  return customFetch<sendResponse>(getSendUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sendEmailCodeRequest,)
  }
);}




export const getSendMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof send>>, TError,{data: SendEmailCodeRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof send>>, TError,{data: SendEmailCodeRequest}, TContext> => {

const mutationKey = ['send'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof send>>, {data: SendEmailCodeRequest}> = (props) => {
          const {data} = props ?? {};

          return  send(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SendMutationResult = NonNullable<Awaited<ReturnType<typeof send>>>
    export type SendMutationBody = SendEmailCodeRequest
    export type SendMutationError = unknown

    /**
 * @summary [ÌïôÏÉù] ÌïôÍµê Ïù¥Î©îÏùº Ïù∏Ï¶ù Î∞úÏÜ°
 */
export const useSend = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof send>>, TError,{data: SendEmailCodeRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof send>>,
        TError,
        {data: SendEmailCodeRequest},
        TContext
      > => {
      return useMutation(getSendMutationOptions(options), queryClient);
    }
    /**
 * ÏÜåÏÖú Î°úÍ∑∏Ïù∏ ÌõÑ Ï∂îÍ∞Ä Ï†ïÎ≥¥Î•º ÏûÖÎ†•ÌïòÏó¨ ÌöåÏõêÍ∞ÄÏûÖÏùÑ ÏôÑÎ£åÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÏÜåÏÖú ÌöåÏõêÍ∞ÄÏûÖ ÏôÑÎ£å
 */
export type completeSocialSignupResponse200 = {
  data: Blob
  status: 200
}

export type completeSocialSignupResponse400 = {
  data: Blob
  status: 400
}

export type completeSocialSignupResponse404 = {
  data: Blob
  status: 404
}

export type completeSocialSignupResponse409 = {
  data: Blob
  status: 409
}
    
export type completeSocialSignupResponseSuccess = (completeSocialSignupResponse200) & {
  headers: Headers;
};
export type completeSocialSignupResponseError = (completeSocialSignupResponse400 | completeSocialSignupResponse404 | completeSocialSignupResponse409) & {
  headers: Headers;
};

export type completeSocialSignupResponse = (completeSocialSignupResponseSuccess | completeSocialSignupResponseError)

export const getCompleteSocialSignupUrl = (params: CompleteSocialSignupParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/complete-social-signup?${stringifiedParams}` : `/api/auth/complete-social-signup`
}

export const completeSocialSignup = async (params: CompleteSocialSignupParams, options?: RequestInit): Promise<completeSocialSignupResponse> => {
  
  return customFetch<completeSocialSignupResponse>(getCompleteSocialSignupUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getCompleteSocialSignupMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSocialSignup>>, TError,{params: CompleteSocialSignupParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof completeSocialSignup>>, TError,{params: CompleteSocialSignupParams}, TContext> => {

const mutationKey = ['completeSocialSignup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeSocialSignup>>, {params: CompleteSocialSignupParams}> = (props) => {
          const {params} = props ?? {};

          return  completeSocialSignup(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteSocialSignupMutationResult = NonNullable<Awaited<ReturnType<typeof completeSocialSignup>>>
    
    export type CompleteSocialSignupMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] ÏÜåÏÖú ÌöåÏõêÍ∞ÄÏûÖ ÏôÑÎ£å
 */
export const useCompleteSocialSignup = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSocialSignup>>, TError,{params: CompleteSocialSignupParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeSocialSignup>>,
        TError,
        {params: CompleteSocialSignupParams},
        TContext
      > => {
      return useMutation(getCompleteSocialSignupMutationOptions(options), queryClient);
    }
    /**
 * ÏïÑÏù¥Îîî ÏÇ¨Ïö© Í∞ÄÎä• Ïó¨Î∂ÄÎ•º ÌôïÏù∏Ìï©ÎãàÎã§. (true: ÏÇ¨Ïö© Í∞ÄÎä•, false: Ï§ëÎ≥µ)
 * @summary [Í≥µÌÜµ] ÏïÑÏù¥Îîî Ï§ëÎ≥µ ÌôïÏù∏
 */
export type checkUsernameAvailabilityResponse200 = {
  data: Blob
  status: 200
}
    
export type checkUsernameAvailabilityResponseSuccess = (checkUsernameAvailabilityResponse200) & {
  headers: Headers;
};
;

export type checkUsernameAvailabilityResponse = (checkUsernameAvailabilityResponseSuccess)

export const getCheckUsernameAvailabilityUrl = (params: CheckUsernameAvailabilityParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/check-username?${stringifiedParams}` : `/api/auth/check-username`
}

export const checkUsernameAvailability = async (params: CheckUsernameAvailabilityParams, options?: RequestInit): Promise<checkUsernameAvailabilityResponse> => {
  
  return customFetch<checkUsernameAvailabilityResponse>(getCheckUsernameAvailabilityUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getCheckUsernameAvailabilityQueryKey = (params?: CheckUsernameAvailabilityParams,) => {
    return [
    `/api/auth/check-username`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getCheckUsernameAvailabilityQueryOptions = <TData = Awaited<ReturnType<typeof checkUsernameAvailability>>, TError = unknown>(params: CheckUsernameAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkUsernameAvailability>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckUsernameAvailabilityQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkUsernameAvailability>>> = ({ signal }) => checkUsernameAvailability(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkUsernameAvailability>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckUsernameAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof checkUsernameAvailability>>>
export type CheckUsernameAvailabilityQueryError = unknown


export function useCheckUsernameAvailability<TData = Awaited<ReturnType<typeof checkUsernameAvailability>>, TError = unknown>(
 params: CheckUsernameAvailabilityParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkUsernameAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkUsernameAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkUsernameAvailability>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckUsernameAvailability<TData = Awaited<ReturnType<typeof checkUsernameAvailability>>, TError = unknown>(
 params: CheckUsernameAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkUsernameAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkUsernameAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkUsernameAvailability>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckUsernameAvailability<TData = Awaited<ReturnType<typeof checkUsernameAvailability>>, TError = unknown>(
 params: CheckUsernameAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkUsernameAvailability>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Í≥µÌÜµ] ÏïÑÏù¥Îîî Ï§ëÎ≥µ ÌôïÏù∏
 */

export function useCheckUsernameAvailability<TData = Awaited<ReturnType<typeof checkUsernameAvailability>>, TError = unknown>(
 params: CheckUsernameAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkUsernameAvailability>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckUsernameAvailabilityQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * ÌöåÏõêÏùÑ ÌÉàÌá¥ Ï≤òÎ¶¨Ìï©ÎãàÎã§. (Soft Delete)
 * @summary [Í≥µÌÜµ] ÌöåÏõê ÌÉàÌá¥
 */
export type withdrawResponse204 = {
  data: Blob
  status: 204
}

export type withdrawResponse400 = {
  data: Blob
  status: 400
}

export type withdrawResponse401 = {
  data: Blob
  status: 401
}
    
export type withdrawResponseSuccess = (withdrawResponse204) & {
  headers: Headers;
};
export type withdrawResponseError = (withdrawResponse400 | withdrawResponse401) & {
  headers: Headers;
};

export type withdrawResponse = (withdrawResponseSuccess | withdrawResponseError)

export const getWithdrawUrl = () => {


  

  return `/api/auth/withdraw`
}

export const withdraw = async (withdrawRequest: WithdrawRequest, options?: RequestInit): Promise<withdrawResponse> => {
  
  return customFetch<withdrawResponse>(getWithdrawUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      withdrawRequest,)
  }
);}




export const getWithdrawMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdraw>>, TError,{data: WithdrawRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof withdraw>>, TError,{data: WithdrawRequest}, TContext> => {

const mutationKey = ['withdraw'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof withdraw>>, {data: WithdrawRequest}> = (props) => {
          const {data} = props ?? {};

          return  withdraw(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type WithdrawMutationResult = NonNullable<Awaited<ReturnType<typeof withdraw>>>
    export type WithdrawMutationBody = WithdrawRequest
    export type WithdrawMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] ÌöåÏõê ÌÉàÌá¥
 */
export const useWithdraw = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdraw>>, TError,{data: WithdrawRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof withdraw>>,
        TError,
        {data: WithdrawRequest},
        TContext
      > => {
      return useMutation(getWithdrawMutationOptions(options), queryClient);
    }
    