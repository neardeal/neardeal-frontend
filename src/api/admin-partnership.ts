/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * LOOKY API Server
 * API Î™ÖÏÑ∏ÏÑú
 * OpenAPI spec version: v1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreatePartnershipRequest,
  ExportPartnershipTemplateParams,
  UpdatePartnershipRequest,
  UploadPartnershipDataBody,
  UploadPartnershipDataParams
} from './generated.schemas';

import { customFetch } from './mutator';



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * ÌäπÏ†ï ÎåÄÌïôÏùò ÌäπÏ†ï Ï°∞ÏßÅÏùò Î™®Îì† Ï†úÌú¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ï°∞ÏßÅÎ≥Ñ Ï†úÌú¥ Î™©Î°ù Ï°∞Ìöå
 */
export type getPartnershipsByOrganizationResponse200 = {
  data: Blob
  status: 200
}
    
export type getPartnershipsByOrganizationResponseSuccess = (getPartnershipsByOrganizationResponse200) & {
  headers: Headers;
};
;

export type getPartnershipsByOrganizationResponse = (getPartnershipsByOrganizationResponseSuccess)

export const getGetPartnershipsByOrganizationUrl = (universityId: number,
    organizationId: number,) => {


  

  return `/api/admin/universities/${universityId}/organizations/${organizationId}/partnerships`
}

export const getPartnershipsByOrganization = async (universityId: number,
    organizationId: number, options?: RequestInit): Promise<getPartnershipsByOrganizationResponse> => {
  
  return customFetch<getPartnershipsByOrganizationResponse>(getGetPartnershipsByOrganizationUrl(universityId,organizationId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPartnershipsByOrganizationQueryKey = (universityId: number,
    organizationId: number,) => {
    return [
    `/api/admin/universities/${universityId}/organizations/${organizationId}/partnerships`
    ] as const;
    }

    
export const getGetPartnershipsByOrganizationQueryOptions = <TData = Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError = unknown>(universityId: number,
    organizationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPartnershipsByOrganizationQueryKey(universityId,organizationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPartnershipsByOrganization>>> = ({ signal }) => getPartnershipsByOrganization(universityId,organizationId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(universityId && organizationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPartnershipsByOrganizationQueryResult = NonNullable<Awaited<ReturnType<typeof getPartnershipsByOrganization>>>
export type GetPartnershipsByOrganizationQueryError = unknown


export function useGetPartnershipsByOrganization<TData = Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError = unknown>(
 universityId: number,
    organizationId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnershipsByOrganization>>,
          TError,
          Awaited<ReturnType<typeof getPartnershipsByOrganization>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPartnershipsByOrganization<TData = Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError = unknown>(
 universityId: number,
    organizationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnershipsByOrganization>>,
          TError,
          Awaited<ReturnType<typeof getPartnershipsByOrganization>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPartnershipsByOrganization<TData = Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError = unknown>(
 universityId: number,
    organizationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ï°∞ÏßÅÎ≥Ñ Ï†úÌú¥ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPartnershipsByOrganization<TData = Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError = unknown>(
 universityId: number,
    organizationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByOrganization>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPartnershipsByOrganizationQueryOptions(universityId,organizationId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * ÌäπÏ†ï ÎåÄÌïôÏùò ÌäπÏ†ï Ï°∞ÏßÅÏóê Ï†úÌú¥Î•º Îã®Í±¥ÏúºÎ°ú Îì±Î°ùÌï©ÎãàÎã§.
 * @summary [Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ Îã®Í±¥ Îì±Î°ù
 */
export type createPartnershipResponse201 = {
  data: Blob
  status: 201
}

export type createPartnershipResponse400 = {
  data: Blob
  status: 400
}

export type createPartnershipResponse403 = {
  data: Blob
  status: 403
}

export type createPartnershipResponse404 = {
  data: Blob
  status: 404
}

export type createPartnershipResponse409 = {
  data: Blob
  status: 409
}
    
export type createPartnershipResponseSuccess = (createPartnershipResponse201) & {
  headers: Headers;
};
export type createPartnershipResponseError = (createPartnershipResponse400 | createPartnershipResponse403 | createPartnershipResponse404 | createPartnershipResponse409) & {
  headers: Headers;
};

export type createPartnershipResponse = (createPartnershipResponseSuccess | createPartnershipResponseError)

export const getCreatePartnershipUrl = (universityId: number,
    organizationId: number,) => {


  

  return `/api/admin/universities/${universityId}/organizations/${organizationId}/partnerships`
}

export const createPartnership = async (universityId: number,
    organizationId: number,
    createPartnershipRequest: CreatePartnershipRequest, options?: RequestInit): Promise<createPartnershipResponse> => {
  
  return customFetch<createPartnershipResponse>(getCreatePartnershipUrl(universityId,organizationId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPartnershipRequest,)
  }
);}




export const getCreatePartnershipMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPartnership>>, TError,{universityId: number;organizationId: number;data: CreatePartnershipRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createPartnership>>, TError,{universityId: number;organizationId: number;data: CreatePartnershipRequest}, TContext> => {

const mutationKey = ['createPartnership'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPartnership>>, {universityId: number;organizationId: number;data: CreatePartnershipRequest}> = (props) => {
          const {universityId,organizationId,data} = props ?? {};

          return  createPartnership(universityId,organizationId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePartnershipMutationResult = NonNullable<Awaited<ReturnType<typeof createPartnership>>>
    export type CreatePartnershipMutationBody = CreatePartnershipRequest
    export type CreatePartnershipMutationError = Blob

    /**
 * @summary [Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ Îã®Í±¥ Îì±Î°ù
 */
export const useCreatePartnership = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPartnership>>, TError,{universityId: number;organizationId: number;data: CreatePartnershipRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPartnership>>,
        TError,
        {universityId: number;organizationId: number;data: CreatePartnershipRequest},
        TContext
      > => {
      return useMutation(getCreatePartnershipMutationOptions(options), queryClient);
    }
    /**
 * ÏóëÏÖÄ ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌïòÏó¨ Ï†úÌú¥ Ï†ïÎ≥¥Î•º ÏùºÍ¥Ñ Îì±Î°ù/ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary [ÌïôÏÉùÌöå/Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ ÏóëÏÖÄÎ°ú Îì±Î°ù
 */
export type uploadPartnershipDataResponse200 = {
  data: Blob
  status: 200
}

export type uploadPartnershipDataResponse400 = {
  data: Blob
  status: 400
}

export type uploadPartnershipDataResponse403 = {
  data: Blob
  status: 403
}
    
export type uploadPartnershipDataResponseSuccess = (uploadPartnershipDataResponse200) & {
  headers: Headers;
};
export type uploadPartnershipDataResponseError = (uploadPartnershipDataResponse400 | uploadPartnershipDataResponse403) & {
  headers: Headers;
};

export type uploadPartnershipDataResponse = (uploadPartnershipDataResponseSuccess | uploadPartnershipDataResponseError)

export const getUploadPartnershipDataUrl = (params?: UploadPartnershipDataParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/admin/partnerships/upload?${stringifiedParams}` : `/api/admin/partnerships/upload`
}

export const uploadPartnershipData = async (uploadPartnershipDataBody: UploadPartnershipDataBody,
    params?: UploadPartnershipDataParams, options?: RequestInit): Promise<uploadPartnershipDataResponse> => {
    const formData = new FormData();
formData.append(`file`, uploadPartnershipDataBody.file);

  return customFetch<uploadPartnershipDataResponse>(getUploadPartnershipDataUrl(params),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getUploadPartnershipDataMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadPartnershipData>>, TError,{data: UploadPartnershipDataBody;params?: UploadPartnershipDataParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof uploadPartnershipData>>, TError,{data: UploadPartnershipDataBody;params?: UploadPartnershipDataParams}, TContext> => {

const mutationKey = ['uploadPartnershipData'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadPartnershipData>>, {data: UploadPartnershipDataBody;params?: UploadPartnershipDataParams}> = (props) => {
          const {data,params} = props ?? {};

          return  uploadPartnershipData(data,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UploadPartnershipDataMutationResult = NonNullable<Awaited<ReturnType<typeof uploadPartnershipData>>>
    export type UploadPartnershipDataMutationBody = UploadPartnershipDataBody
    export type UploadPartnershipDataMutationError = Blob

    /**
 * @summary [ÌïôÏÉùÌöå/Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ ÏóëÏÖÄÎ°ú Îì±Î°ù
 */
export const useUploadPartnershipData = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadPartnershipData>>, TError,{data: UploadPartnershipDataBody;params?: UploadPartnershipDataParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadPartnershipData>>,
        TError,
        {data: UploadPartnershipDataBody;params?: UploadPartnershipDataParams},
        TContext
      > => {
      return useMutation(getUploadPartnershipDataMutationOptions(options), queryClient);
    }
    /**
 * Ï†úÌú¥Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary [Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ ÏÇ≠Ï†ú
 */
export type deletePartnershipResponse204 = {
  data: Blob
  status: 204
}

export type deletePartnershipResponse403 = {
  data: Blob
  status: 403
}

export type deletePartnershipResponse404 = {
  data: Blob
  status: 404
}
    
export type deletePartnershipResponseSuccess = (deletePartnershipResponse204) & {
  headers: Headers;
};
export type deletePartnershipResponseError = (deletePartnershipResponse403 | deletePartnershipResponse404) & {
  headers: Headers;
};

export type deletePartnershipResponse = (deletePartnershipResponseSuccess | deletePartnershipResponseError)

export const getDeletePartnershipUrl = (partnershipId: number,) => {


  

  return `/api/admin/partnerships/${partnershipId}`
}

export const deletePartnership = async (partnershipId: number, options?: RequestInit): Promise<deletePartnershipResponse> => {
  
  return customFetch<deletePartnershipResponse>(getDeletePartnershipUrl(partnershipId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeletePartnershipMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePartnership>>, TError,{partnershipId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePartnership>>, TError,{partnershipId: number}, TContext> => {

const mutationKey = ['deletePartnership'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePartnership>>, {partnershipId: number}> = (props) => {
          const {partnershipId} = props ?? {};

          return  deletePartnership(partnershipId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePartnershipMutationResult = NonNullable<Awaited<ReturnType<typeof deletePartnership>>>
    
    export type DeletePartnershipMutationError = Blob

    /**
 * @summary [Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ ÏÇ≠Ï†ú
 */
export const useDeletePartnership = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePartnership>>, TError,{partnershipId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePartnership>>,
        TError,
        {partnershipId: number},
        TContext
      > => {
      return useMutation(getDeletePartnershipMutationOptions(options), queryClient);
    }
    /**
 * Ï†úÌú¥ ÎÇ¥Ïö©ÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary [Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ ÌòúÌÉù ÏàòÏ†ï
 */
export type updatePartnershipBenefitResponse200 = {
  data: Blob
  status: 200
}

export type updatePartnershipBenefitResponse403 = {
  data: Blob
  status: 403
}

export type updatePartnershipBenefitResponse404 = {
  data: Blob
  status: 404
}
    
export type updatePartnershipBenefitResponseSuccess = (updatePartnershipBenefitResponse200) & {
  headers: Headers;
};
export type updatePartnershipBenefitResponseError = (updatePartnershipBenefitResponse403 | updatePartnershipBenefitResponse404) & {
  headers: Headers;
};

export type updatePartnershipBenefitResponse = (updatePartnershipBenefitResponseSuccess | updatePartnershipBenefitResponseError)

export const getUpdatePartnershipBenefitUrl = (partnershipId: number,) => {


  

  return `/api/admin/partnerships/${partnershipId}`
}

export const updatePartnershipBenefit = async (partnershipId: number,
    updatePartnershipRequest: UpdatePartnershipRequest, options?: RequestInit): Promise<updatePartnershipBenefitResponse> => {
  
  return customFetch<updatePartnershipBenefitResponse>(getUpdatePartnershipBenefitUrl(partnershipId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePartnershipRequest,)
  }
);}




export const getUpdatePartnershipBenefitMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePartnershipBenefit>>, TError,{partnershipId: number;data: UpdatePartnershipRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePartnershipBenefit>>, TError,{partnershipId: number;data: UpdatePartnershipRequest}, TContext> => {

const mutationKey = ['updatePartnershipBenefit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePartnershipBenefit>>, {partnershipId: number;data: UpdatePartnershipRequest}> = (props) => {
          const {partnershipId,data} = props ?? {};

          return  updatePartnershipBenefit(partnershipId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePartnershipBenefitMutationResult = NonNullable<Awaited<ReturnType<typeof updatePartnershipBenefit>>>
    export type UpdatePartnershipBenefitMutationBody = UpdatePartnershipRequest
    export type UpdatePartnershipBenefitMutationError = Blob

    /**
 * @summary [Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ ÌòúÌÉù ÏàòÏ†ï
 */
export const useUpdatePartnershipBenefit = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePartnershipBenefit>>, TError,{partnershipId: number;data: UpdatePartnershipRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePartnershipBenefit>>,
        TError,
        {partnershipId: number;data: UpdatePartnershipRequest},
        TContext
      > => {
      return useMutation(getUpdatePartnershipBenefitMutationOptions(options), queryClient);
    }
    /**
 * ÌäπÏ†ï ÎåÄÌïôÏùò Î™®Îì† Ï†úÌú¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎåÄÌïôÎ≥Ñ Ï†úÌú¥ Î™©Î°ù Ï°∞Ìöå
 */
export type getPartnershipsByUniversityResponse200 = {
  data: Blob
  status: 200
}
    
export type getPartnershipsByUniversityResponseSuccess = (getPartnershipsByUniversityResponse200) & {
  headers: Headers;
};
;

export type getPartnershipsByUniversityResponse = (getPartnershipsByUniversityResponseSuccess)

export const getGetPartnershipsByUniversityUrl = (universityId: number,) => {


  

  return `/api/admin/universities/${universityId}/partnerships`
}

export const getPartnershipsByUniversity = async (universityId: number, options?: RequestInit): Promise<getPartnershipsByUniversityResponse> => {
  
  return customFetch<getPartnershipsByUniversityResponse>(getGetPartnershipsByUniversityUrl(universityId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPartnershipsByUniversityQueryKey = (universityId: number,) => {
    return [
    `/api/admin/universities/${universityId}/partnerships`
    ] as const;
    }

    
export const getGetPartnershipsByUniversityQueryOptions = <TData = Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError = unknown>(universityId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPartnershipsByUniversityQueryKey(universityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPartnershipsByUniversity>>> = ({ signal }) => getPartnershipsByUniversity(universityId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(universityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPartnershipsByUniversityQueryResult = NonNullable<Awaited<ReturnType<typeof getPartnershipsByUniversity>>>
export type GetPartnershipsByUniversityQueryError = unknown


export function useGetPartnershipsByUniversity<TData = Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError = unknown>(
 universityId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnershipsByUniversity>>,
          TError,
          Awaited<ReturnType<typeof getPartnershipsByUniversity>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPartnershipsByUniversity<TData = Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError = unknown>(
 universityId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnershipsByUniversity>>,
          TError,
          Awaited<ReturnType<typeof getPartnershipsByUniversity>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPartnershipsByUniversity<TData = Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError = unknown>(
 universityId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÌïôÎ≥Ñ Ï†úÌú¥ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPartnershipsByUniversity<TData = Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError = unknown>(
 universityId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPartnershipsByUniversity>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPartnershipsByUniversityQueryOptions(universityId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * ÌäπÏ†ï ÎåÄÌïôÏùò ÏÉÅÏ†ê Î¶¨Ïä§Ìä∏Í∞Ä Ìè¨Ìï®Îêú ÏóëÏÖÄ ÌÖúÌîåÎ¶øÏùÑ Îã§Ïö¥Î°úÎìúÌï©ÎãàÎã§.
 * @summary [Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ Îì±Î°ù ÌÖúÌîåÎ¶ø Îã§Ïö¥Î°úÎìú
 */
export type exportPartnershipTemplateResponse200 = {
  data: Blob
  status: 200
}

export type exportPartnershipTemplateResponse403 = {
  data: Blob
  status: 403
}
    
export type exportPartnershipTemplateResponseSuccess = (exportPartnershipTemplateResponse200) & {
  headers: Headers;
};
export type exportPartnershipTemplateResponseError = (exportPartnershipTemplateResponse403) & {
  headers: Headers;
};

export type exportPartnershipTemplateResponse = (exportPartnershipTemplateResponseSuccess | exportPartnershipTemplateResponseError)

export const getExportPartnershipTemplateUrl = (params: ExportPartnershipTemplateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/admin/partnerships/template?${stringifiedParams}` : `/api/admin/partnerships/template`
}

export const exportPartnershipTemplate = async (params: ExportPartnershipTemplateParams, options?: RequestInit): Promise<exportPartnershipTemplateResponse> => {
  
  return customFetch<exportPartnershipTemplateResponse>(getExportPartnershipTemplateUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getExportPartnershipTemplateQueryKey = (params?: ExportPartnershipTemplateParams,) => {
    return [
    `/api/admin/partnerships/template`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getExportPartnershipTemplateQueryOptions = <TData = Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError = Blob>(params: ExportPartnershipTemplateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExportPartnershipTemplateQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof exportPartnershipTemplate>>> = ({ signal }) => exportPartnershipTemplate(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExportPartnershipTemplateQueryResult = NonNullable<Awaited<ReturnType<typeof exportPartnershipTemplate>>>
export type ExportPartnershipTemplateQueryError = Blob


export function useExportPartnershipTemplate<TData = Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError = Blob>(
 params: ExportPartnershipTemplateParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportPartnershipTemplate>>,
          TError,
          Awaited<ReturnType<typeof exportPartnershipTemplate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportPartnershipTemplate<TData = Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError = Blob>(
 params: ExportPartnershipTemplateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportPartnershipTemplate>>,
          TError,
          Awaited<ReturnType<typeof exportPartnershipTemplate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportPartnershipTemplate<TData = Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError = Blob>(
 params: ExportPartnershipTemplateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Í¥ÄÎ¶¨Ïûê] Ï†úÌú¥ Îì±Î°ù ÌÖúÌîåÎ¶ø Îã§Ïö¥Î°úÎìú
 */

export function useExportPartnershipTemplate<TData = Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError = Blob>(
 params: ExportPartnershipTemplateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportPartnershipTemplate>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExportPartnershipTemplateQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




