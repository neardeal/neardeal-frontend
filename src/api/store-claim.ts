/**
 * Generated by orval v8.0.2 üç∫
 * Do not edit manually.
 * LOOKY API Server
 * API Î™ÖÏÑ∏ÏÑú
 * OpenAPI spec version: v1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BizVerificationRequest,
  CreateStoreClaimsBody,
  GetStoreClaimsParams,
  SearchUnclaimedStoresParams,
  StoreClaimRejectionRequest
} from './generated.schemas';

import { customFetch } from './mutator';



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * ÏÇ¨Ïû•ÎãòÏù¥ ÏÉÅÏ†êÏóê ÎåÄÌï¥ ÏÜåÏú†Î•º ÏöîÏ≤≠ÌïòÏó¨ Ïã¨ÏÇ¨ ÎåÄÏÉÅÏù¥ Îê©ÎãàÎã§.
 * @summary [Ï†êÏ£º] ÏÉÅÏ†ê ÏÜåÏú† ÏöîÏ≤≠ Îì±Î°ù
 */
export type createStoreClaimsResponse200 = {
  data: Blob
  status: 200
}
    
export type createStoreClaimsResponseSuccess = (createStoreClaimsResponse200) & {
  headers: Headers;
};
;

export type createStoreClaimsResponse = (createStoreClaimsResponseSuccess)

export const getCreateStoreClaimsUrl = () => {


  

  return `/api/store-claims`
}

export const createStoreClaims = async (createStoreClaimsBody: CreateStoreClaimsBody, options?: RequestInit): Promise<createStoreClaimsResponse> => {
  
  return customFetch<createStoreClaimsResponse>(getCreateStoreClaimsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createStoreClaimsBody,)
  }
);}




export const getCreateStoreClaimsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStoreClaims>>, TError,{data: CreateStoreClaimsBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createStoreClaims>>, TError,{data: CreateStoreClaimsBody}, TContext> => {

const mutationKey = ['createStoreClaims'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStoreClaims>>, {data: CreateStoreClaimsBody}> = (props) => {
          const {data} = props ?? {};

          return  createStoreClaims(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateStoreClaimsMutationResult = NonNullable<Awaited<ReturnType<typeof createStoreClaims>>>
    export type CreateStoreClaimsMutationBody = CreateStoreClaimsBody
    export type CreateStoreClaimsMutationError = unknown

    /**
 * @summary [Ï†êÏ£º] ÏÉÅÏ†ê ÏÜåÏú† ÏöîÏ≤≠ Îì±Î°ù
 */
export const useCreateStoreClaims = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStoreClaims>>, TError,{data: CreateStoreClaimsBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createStoreClaims>>,
        TError,
        {data: CreateStoreClaimsBody},
        TContext
      > => {
      return useMutation(getCreateStoreClaimsMutationOptions(options), queryClient);
    }
    /**
 * ÏÇ¨ÏóÖÏûêÎì±Î°ùÎ≤àÌò∏Ïùò Ïú†Ìö®ÏÑ±ÏùÑ Í≤ÄÏ¶ùÌï©ÎãàÎã§.
 * @summary [Ï†êÏ£º] ÏÇ¨ÏóÖÏûêÎì±Î°ùÎ≤àÌò∏ Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù
 */
export type verifyBizRegNoResponse200 = {
  data: Blob
  status: 200
}
    
export type verifyBizRegNoResponseSuccess = (verifyBizRegNoResponse200) & {
  headers: Headers;
};
;

export type verifyBizRegNoResponse = (verifyBizRegNoResponseSuccess)

export const getVerifyBizRegNoUrl = () => {


  

  return `/api/biz-reg-no/verify`
}

export const verifyBizRegNo = async (bizVerificationRequest: BizVerificationRequest, options?: RequestInit): Promise<verifyBizRegNoResponse> => {
  
  return customFetch<verifyBizRegNoResponse>(getVerifyBizRegNoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bizVerificationRequest,)
  }
);}




export const getVerifyBizRegNoMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyBizRegNo>>, TError,{data: BizVerificationRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof verifyBizRegNo>>, TError,{data: BizVerificationRequest}, TContext> => {

const mutationKey = ['verifyBizRegNo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyBizRegNo>>, {data: BizVerificationRequest}> = (props) => {
          const {data} = props ?? {};

          return  verifyBizRegNo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyBizRegNoMutationResult = NonNullable<Awaited<ReturnType<typeof verifyBizRegNo>>>
    export type VerifyBizRegNoMutationBody = BizVerificationRequest
    export type VerifyBizRegNoMutationError = unknown

    /**
 * @summary [Ï†êÏ£º] ÏÇ¨ÏóÖÏûêÎì±Î°ùÎ≤àÌò∏ Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù
 */
export const useVerifyBizRegNo = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyBizRegNo>>, TError,{data: BizVerificationRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verifyBizRegNo>>,
        TError,
        {data: BizVerificationRequest},
        TContext
      > => {
      return useMutation(getVerifyBizRegNoMutationOptions(options), queryClient);
    }
    /**
 * ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ÏùÑ Î∞òÎ†§Ìï©ÎãàÎã§.
 * @summary [Í¥ÄÎ¶¨Ïûê] ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ Î∞òÎ†§
 */
export type rejectResponse200 = {
  data: Blob
  status: 200
}
    
export type rejectResponseSuccess = (rejectResponse200) & {
  headers: Headers;
};
;

export type rejectResponse = (rejectResponseSuccess)

export const getRejectUrl = (claimId: number,) => {


  

  return `/api/admin/store-claims/${claimId}/reject`
}

export const reject = async (claimId: number,
    storeClaimRejectionRequest: StoreClaimRejectionRequest, options?: RequestInit): Promise<rejectResponse> => {
  
  return customFetch<rejectResponse>(getRejectUrl(claimId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeClaimRejectionRequest,)
  }
);}




export const getRejectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reject>>, TError,{claimId: number;data: StoreClaimRejectionRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof reject>>, TError,{claimId: number;data: StoreClaimRejectionRequest}, TContext> => {

const mutationKey = ['reject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reject>>, {claimId: number;data: StoreClaimRejectionRequest}> = (props) => {
          const {claimId,data} = props ?? {};

          return  reject(claimId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RejectMutationResult = NonNullable<Awaited<ReturnType<typeof reject>>>
    export type RejectMutationBody = StoreClaimRejectionRequest
    export type RejectMutationError = unknown

    /**
 * @summary [Í¥ÄÎ¶¨Ïûê] ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ Î∞òÎ†§
 */
export const useReject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reject>>, TError,{claimId: number;data: StoreClaimRejectionRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reject>>,
        TError,
        {claimId: number;data: StoreClaimRejectionRequest},
        TContext
      > => {
      return useMutation(getRejectMutationOptions(options), queryClient);
    }
    /**
 * ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ÏùÑ ÏäπÏù∏Ìï©ÎãàÎã§.
 * @summary [Í¥ÄÎ¶¨Ïûê] ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ ÏäπÏù∏
 */
export type approveResponse200 = {
  data: Blob
  status: 200
}
    
export type approveResponseSuccess = (approveResponse200) & {
  headers: Headers;
};
;

export type approveResponse = (approveResponseSuccess)

export const getApproveUrl = (claimId: number,) => {


  

  return `/api/admin/store-claims/${claimId}/approve`
}

export const approve = async (claimId: number, options?: RequestInit): Promise<approveResponse> => {
  
  return customFetch<approveResponse>(getApproveUrl(claimId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getApproveMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approve>>, TError,{claimId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof approve>>, TError,{claimId: number}, TContext> => {

const mutationKey = ['approve'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof approve>>, {claimId: number}> = (props) => {
          const {claimId} = props ?? {};

          return  approve(claimId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ApproveMutationResult = NonNullable<Awaited<ReturnType<typeof approve>>>
    
    export type ApproveMutationError = unknown

    /**
 * @summary [Í¥ÄÎ¶¨Ïûê] ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ ÏäπÏù∏
 */
export const useApprove = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approve>>, TError,{claimId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof approve>>,
        TError,
        {claimId: number},
        TContext
      > => {
      return useMutation(getApproveMutationOptions(options), queryClient);
    }
    /**
 * ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠Ïóê Í¥ÄÎ¶¨Ïûê Î©îÎ™®Î•º ÎÇ®ÍπÅÎãàÎã§.
 * @summary [Í¥ÄÎ¶¨Ïûê] ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ Í¥ÄÎ¶¨Ïûê Î©îÎ™® Îì±Î°ù Î∞è ÏàòÏ†ï
 */
export type updateMemoResponse200 = {
  data: Blob
  status: 200
}
    
export type updateMemoResponseSuccess = (updateMemoResponse200) & {
  headers: Headers;
};
;

export type updateMemoResponse = (updateMemoResponseSuccess)

export const getUpdateMemoUrl = (claimId: number,) => {


  

  return `/api/admin/store-claims/${claimId}/memo`
}

export const updateMemo = async (claimId: number,
    updateMemoBody: string, options?: RequestInit): Promise<updateMemoResponse> => {
  
  return customFetch<updateMemoResponse>(getUpdateMemoUrl(claimId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateMemoBody,)
  }
);}




export const getUpdateMemoMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMemo>>, TError,{claimId: number;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateMemo>>, TError,{claimId: number;data: string}, TContext> => {

const mutationKey = ['updateMemo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMemo>>, {claimId: number;data: string}> = (props) => {
          const {claimId,data} = props ?? {};

          return  updateMemo(claimId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMemoMutationResult = NonNullable<Awaited<ReturnType<typeof updateMemo>>>
    export type UpdateMemoMutationBody = string
    export type UpdateMemoMutationError = unknown

    /**
 * @summary [Í¥ÄÎ¶¨Ïûê] ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ Í¥ÄÎ¶¨Ïûê Î©îÎ™® Îì±Î°ù Î∞è ÏàòÏ†ï
 */
export const useUpdateMemo = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMemo>>, TError,{claimId: number;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateMemo>>,
        TError,
        {claimId: number;data: string},
        TContext
      > => {
      return useMutation(getUpdateMemoMutationOptions(options), queryClient);
    }
    /**
 * ÏãúÏä§ÌÖúÏóê Îì±Î°ùÎêú ÎØ∏Îì±Î°ù ÏÉÅÏ†êÏùÑ Ïù¥Î¶Ñ ÎòêÎäî Ï£ºÏÜåÎ°ú Í≤ÄÏÉâÌï©ÎãàÎã§.
 * @summary [Ï†êÏ£º] ÎØ∏Îì±Î°ù ÏÉÅÏ†ê Í≤ÄÏÉâ
 */
export type searchUnclaimedStoresResponse200 = {
  data: Blob
  status: 200
}
    
export type searchUnclaimedStoresResponseSuccess = (searchUnclaimedStoresResponse200) & {
  headers: Headers;
};
;

export type searchUnclaimedStoresResponse = (searchUnclaimedStoresResponseSuccess)

export const getSearchUnclaimedStoresUrl = (params: SearchUnclaimedStoresParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/store-claims/search?${stringifiedParams}` : `/api/store-claims/search`
}

export const searchUnclaimedStores = async (params: SearchUnclaimedStoresParams, options?: RequestInit): Promise<searchUnclaimedStoresResponse> => {
  
  return customFetch<searchUnclaimedStoresResponse>(getSearchUnclaimedStoresUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getSearchUnclaimedStoresQueryKey = (params?: SearchUnclaimedStoresParams,) => {
    return [
    `/api/store-claims/search`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getSearchUnclaimedStoresQueryOptions = <TData = Awaited<ReturnType<typeof searchUnclaimedStores>>, TError = unknown>(params: SearchUnclaimedStoresParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUnclaimedStores>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchUnclaimedStoresQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUnclaimedStores>>> = ({ signal }) => searchUnclaimedStores(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchUnclaimedStores>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchUnclaimedStoresQueryResult = NonNullable<Awaited<ReturnType<typeof searchUnclaimedStores>>>
export type SearchUnclaimedStoresQueryError = unknown


export function useSearchUnclaimedStores<TData = Awaited<ReturnType<typeof searchUnclaimedStores>>, TError = unknown>(
 params: SearchUnclaimedStoresParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUnclaimedStores>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUnclaimedStores>>,
          TError,
          Awaited<ReturnType<typeof searchUnclaimedStores>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchUnclaimedStores<TData = Awaited<ReturnType<typeof searchUnclaimedStores>>, TError = unknown>(
 params: SearchUnclaimedStoresParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUnclaimedStores>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUnclaimedStores>>,
          TError,
          Awaited<ReturnType<typeof searchUnclaimedStores>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchUnclaimedStores<TData = Awaited<ReturnType<typeof searchUnclaimedStores>>, TError = unknown>(
 params: SearchUnclaimedStoresParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUnclaimedStores>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Ï†êÏ£º] ÎØ∏Îì±Î°ù ÏÉÅÏ†ê Í≤ÄÏÉâ
 */

export function useSearchUnclaimedStores<TData = Awaited<ReturnType<typeof searchUnclaimedStores>>, TError = unknown>(
 params: SearchUnclaimedStoresParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUnclaimedStores>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchUnclaimedStoresQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§. status ÌååÎùºÎØ∏ÌÑ∞Î°ú ÏÉÅÌÉúÎ≥Ñ Ï°∞ÌöåÍ∞Ä Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary [Í¥ÄÎ¶¨Ïûê] ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */
export type getStoreClaimsResponse200 = {
  data: Blob
  status: 200
}
    
export type getStoreClaimsResponseSuccess = (getStoreClaimsResponse200) & {
  headers: Headers;
};
;

export type getStoreClaimsResponse = (getStoreClaimsResponseSuccess)

export const getGetStoreClaimsUrl = (params: GetStoreClaimsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/admin/store-claims?${stringifiedParams}` : `/api/admin/store-claims`
}

export const getStoreClaims = async (params: GetStoreClaimsParams, options?: RequestInit): Promise<getStoreClaimsResponse> => {
  
  return customFetch<getStoreClaimsResponse>(getGetStoreClaimsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetStoreClaimsQueryKey = (params?: GetStoreClaimsParams,) => {
    return [
    `/api/admin/store-claims`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetStoreClaimsQueryOptions = <TData = Awaited<ReturnType<typeof getStoreClaims>>, TError = unknown>(params: GetStoreClaimsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreClaims>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStoreClaimsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoreClaims>>> = ({ signal }) => getStoreClaims(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStoreClaims>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStoreClaimsQueryResult = NonNullable<Awaited<ReturnType<typeof getStoreClaims>>>
export type GetStoreClaimsQueryError = unknown


export function useGetStoreClaims<TData = Awaited<ReturnType<typeof getStoreClaims>>, TError = unknown>(
 params: GetStoreClaimsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreClaims>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreClaims>>,
          TError,
          Awaited<ReturnType<typeof getStoreClaims>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStoreClaims<TData = Awaited<ReturnType<typeof getStoreClaims>>, TError = unknown>(
 params: GetStoreClaimsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreClaims>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreClaims>>,
          TError,
          Awaited<ReturnType<typeof getStoreClaims>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStoreClaims<TData = Awaited<ReturnType<typeof getStoreClaims>>, TError = unknown>(
 params: GetStoreClaimsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreClaims>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Í¥ÄÎ¶¨Ïûê] ÏÉÅÏ†ê ÏÜåÏú†Í∂å ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetStoreClaims<TData = Awaited<ReturnType<typeof getStoreClaims>>, TError = unknown>(
 params: GetStoreClaimsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreClaims>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStoreClaimsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




