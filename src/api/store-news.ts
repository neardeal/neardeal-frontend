/**
 * Generated by orval v8.0.2 üç∫
 * Do not edit manually.
 * NEARDEAL API Server
 * API Î™ÖÏÑ∏ÏÑú
 * OpenAPI spec version: v1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CommonResponseLong,
  CommonResponsePageResponseStoreNewsCommentResponse,
  CommonResponsePageResponseStoreNewsResponse,
  CommonResponseStoreNewsResponse,
  CommonResponseVoid,
  CreateStoreNewsBody,
  CreateStoreNewsCommentRequest,
  GetCommentsParams,
  GetStoreNewsListParams,
  UpdateStoreNewsBody
} from './generated.schemas';

import { customFetch } from './mutator';



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Í∞ÄÍ≤åÏùò ÏÜåÏãù Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÏÜåÏãù Î™©Î°ù Ï°∞Ìöå
 */
export type getStoreNewsListResponse200 = {
  data: CommonResponsePageResponseStoreNewsResponse
  status: 200
}
    
export type getStoreNewsListResponseSuccess = (getStoreNewsListResponse200) & {
  headers: Headers;
};
;

export type getStoreNewsListResponse = (getStoreNewsListResponseSuccess)

export const getGetStoreNewsListUrl = (storeId: number,
    params: GetStoreNewsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/stores/${storeId}/news?${stringifiedParams}` : `/api/stores/${storeId}/news`
}

export const getStoreNewsList = async (storeId: number,
    params: GetStoreNewsListParams, options?: RequestInit): Promise<getStoreNewsListResponse> => {
  
  return customFetch<getStoreNewsListResponse>(getGetStoreNewsListUrl(storeId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetStoreNewsListQueryKey = (storeId?: number,
    params?: GetStoreNewsListParams,) => {
    return [
    `/api/stores/${storeId}/news`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetStoreNewsListQueryOptions = <TData = Awaited<ReturnType<typeof getStoreNewsList>>, TError = unknown>(storeId: number,
    params: GetStoreNewsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNewsList>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStoreNewsListQueryKey(storeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoreNewsList>>> = ({ signal }) => getStoreNewsList(storeId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(storeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStoreNewsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStoreNewsListQueryResult = NonNullable<Awaited<ReturnType<typeof getStoreNewsList>>>
export type GetStoreNewsListQueryError = unknown


export function useGetStoreNewsList<TData = Awaited<ReturnType<typeof getStoreNewsList>>, TError = unknown>(
 storeId: number,
    params: GetStoreNewsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNewsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreNewsList>>,
          TError,
          Awaited<ReturnType<typeof getStoreNewsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStoreNewsList<TData = Awaited<ReturnType<typeof getStoreNewsList>>, TError = unknown>(
 storeId: number,
    params: GetStoreNewsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNewsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreNewsList>>,
          TError,
          Awaited<ReturnType<typeof getStoreNewsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStoreNewsList<TData = Awaited<ReturnType<typeof getStoreNewsList>>, TError = unknown>(
 storeId: number,
    params: GetStoreNewsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNewsList>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Í≥µÌÜµ] ÏÜåÏãù Î™©Î°ù Ï°∞Ìöå
 */

export function useGetStoreNewsList<TData = Awaited<ReturnType<typeof getStoreNewsList>>, TError = unknown>(
 storeId: number,
    params: GetStoreNewsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNewsList>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStoreNewsListQueryOptions(storeId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Í∞ÄÍ≤åÏóê ÏÉàÎ°úÏö¥ ÏÜåÏãùÏùÑ Îì±Î°ùÌï©ÎãàÎã§.
 * @summary [Ï†êÏ£º] ÏÜåÏãù Îì±Î°ù
 */
export type createStoreNewsResponse201 = {
  data: CommonResponseLong
  status: 201
}

export type createStoreNewsResponse403 = {
  data: CommonResponseLong
  status: 403
}

export type createStoreNewsResponse404 = {
  data: CommonResponseLong
  status: 404
}
    
export type createStoreNewsResponseSuccess = (createStoreNewsResponse201) & {
  headers: Headers;
};
export type createStoreNewsResponseError = (createStoreNewsResponse403 | createStoreNewsResponse404) & {
  headers: Headers;
};

export type createStoreNewsResponse = (createStoreNewsResponseSuccess | createStoreNewsResponseError)

export const getCreateStoreNewsUrl = (storeId: number,) => {


  

  return `/api/stores/${storeId}/news`
}

export const createStoreNews = async (storeId: number,
    createStoreNewsBody: CreateStoreNewsBody, options?: RequestInit): Promise<createStoreNewsResponse> => {
  
  return customFetch<createStoreNewsResponse>(getCreateStoreNewsUrl(storeId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createStoreNewsBody,)
  }
);}




export const getCreateStoreNewsMutationOptions = <TError = CommonResponseLong,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStoreNews>>, TError,{storeId: number;data: CreateStoreNewsBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createStoreNews>>, TError,{storeId: number;data: CreateStoreNewsBody}, TContext> => {

const mutationKey = ['createStoreNews'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStoreNews>>, {storeId: number;data: CreateStoreNewsBody}> = (props) => {
          const {storeId,data} = props ?? {};

          return  createStoreNews(storeId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateStoreNewsMutationResult = NonNullable<Awaited<ReturnType<typeof createStoreNews>>>
    export type CreateStoreNewsMutationBody = CreateStoreNewsBody
    export type CreateStoreNewsMutationError = CommonResponseLong

    /**
 * @summary [Ï†êÏ£º] ÏÜåÏãù Îì±Î°ù
 */
export const useCreateStoreNews = <TError = CommonResponseLong,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStoreNews>>, TError,{storeId: number;data: CreateStoreNewsBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createStoreNews>>,
        TError,
        {storeId: number;data: CreateStoreNewsBody},
        TContext
      > => {
      return useMutation(getCreateStoreNewsMutationOptions(options), queryClient);
    }
    /**
 * ÏÜåÏãùÏóê Ï¢ãÏïÑÏöîÎ•º ÎàÑÎ•¥Í±∞ÎÇò Ï∑®ÏÜåÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÏÜåÏãù Ï¢ãÏïÑÏöî ÌÜ†Í∏Ä
 */
export type toggleLikeResponse200 = {
  data: CommonResponseVoid
  status: 200
}
    
export type toggleLikeResponseSuccess = (toggleLikeResponse200) & {
  headers: Headers;
};
;

export type toggleLikeResponse = (toggleLikeResponseSuccess)

export const getToggleLikeUrl = (newsId: number,) => {


  

  return `/api/store-news/${newsId}/likes`
}

export const toggleLike = async (newsId: number, options?: RequestInit): Promise<toggleLikeResponse> => {
  
  return customFetch<toggleLikeResponse>(getToggleLikeUrl(newsId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getToggleLikeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleLike>>, TError,{newsId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof toggleLike>>, TError,{newsId: number}, TContext> => {

const mutationKey = ['toggleLike'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleLike>>, {newsId: number}> = (props) => {
          const {newsId} = props ?? {};

          return  toggleLike(newsId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ToggleLikeMutationResult = NonNullable<Awaited<ReturnType<typeof toggleLike>>>
    
    export type ToggleLikeMutationError = unknown

    /**
 * @summary [Í≥µÌÜµ] ÏÜåÏãù Ï¢ãÏïÑÏöî ÌÜ†Í∏Ä
 */
export const useToggleLike = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleLike>>, TError,{newsId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof toggleLike>>,
        TError,
        {newsId: number},
        TContext
      > => {
      return useMutation(getToggleLikeMutationOptions(options), queryClient);
    }
    /**
 * ÏÜåÏãùÏùò ÎåìÍ∏Ä Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÎåìÍ∏Ä Î™©Î°ù Ï°∞Ìöå
 */
export type getCommentsResponse200 = {
  data: CommonResponsePageResponseStoreNewsCommentResponse
  status: 200
}
    
export type getCommentsResponseSuccess = (getCommentsResponse200) & {
  headers: Headers;
};
;

export type getCommentsResponse = (getCommentsResponseSuccess)

export const getGetCommentsUrl = (newsId: number,
    params: GetCommentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/store-news/${newsId}/comments?${stringifiedParams}` : `/api/store-news/${newsId}/comments`
}

export const getComments = async (newsId: number,
    params: GetCommentsParams, options?: RequestInit): Promise<getCommentsResponse> => {
  
  return customFetch<getCommentsResponse>(getGetCommentsUrl(newsId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCommentsQueryKey = (newsId?: number,
    params?: GetCommentsParams,) => {
    return [
    `/api/store-news/${newsId}/comments`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetCommentsQueryOptions = <TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(newsId: number,
    params: GetCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCommentsQueryKey(newsId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getComments>>> = ({ signal }) => getComments(newsId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(newsId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCommentsQueryResult = NonNullable<Awaited<ReturnType<typeof getComments>>>
export type GetCommentsQueryError = unknown


export function useGetComments<TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(
 newsId: number,
    params: GetCommentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetComments<TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(
 newsId: number,
    params: GetCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComments>>,
          TError,
          Awaited<ReturnType<typeof getComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetComments<TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(
 newsId: number,
    params: GetCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Í≥µÌÜµ] ÎåìÍ∏Ä Î™©Î°ù Ï°∞Ìöå
 */

export function useGetComments<TData = Awaited<ReturnType<typeof getComments>>, TError = unknown>(
 newsId: number,
    params: GetCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCommentsQueryOptions(newsId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * ÏÜåÏãùÏóê ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±Ìï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÎåìÍ∏Ä ÏûëÏÑ±
 */
export type createCommentResponse200 = {
  data: CommonResponseLong
  status: 200
}
    
export type createCommentResponseSuccess = (createCommentResponse200) & {
  headers: Headers;
};
;

export type createCommentResponse = (createCommentResponseSuccess)

export const getCreateCommentUrl = (newsId: number,) => {


  

  return `/api/store-news/${newsId}/comments`
}

export const createComment = async (newsId: number,
    createStoreNewsCommentRequest: CreateStoreNewsCommentRequest, options?: RequestInit): Promise<createCommentResponse> => {
  
  return customFetch<createCommentResponse>(getCreateCommentUrl(newsId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createStoreNewsCommentRequest,)
  }
);}




export const getCreateCommentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{newsId: number;data: CreateStoreNewsCommentRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{newsId: number;data: CreateStoreNewsCommentRequest}, TContext> => {

const mutationKey = ['createComment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createComment>>, {newsId: number;data: CreateStoreNewsCommentRequest}> = (props) => {
          const {newsId,data} = props ?? {};

          return  createComment(newsId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof createComment>>>
    export type CreateCommentMutationBody = CreateStoreNewsCommentRequest
    export type CreateCommentMutationError = unknown

    /**
 * @summary [Í≥µÌÜµ] ÎåìÍ∏Ä ÏûëÏÑ±
 */
export const useCreateComment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{newsId: number;data: CreateStoreNewsCommentRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createComment>>,
        TError,
        {newsId: number;data: CreateStoreNewsCommentRequest},
        TContext
      > => {
      return useMutation(getCreateCommentMutationOptions(options), queryClient);
    }
    /**
 * ÏÜåÏãù ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÏÜåÏãù ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export type getStoreNewsResponse200 = {
  data: CommonResponseStoreNewsResponse
  status: 200
}
    
export type getStoreNewsResponseSuccess = (getStoreNewsResponse200) & {
  headers: Headers;
};
;

export type getStoreNewsResponse = (getStoreNewsResponseSuccess)

export const getGetStoreNewsUrl = (newsId: number,) => {


  

  return `/api/store-news/${newsId}`
}

export const getStoreNews = async (newsId: number, options?: RequestInit): Promise<getStoreNewsResponse> => {
  
  return customFetch<getStoreNewsResponse>(getGetStoreNewsUrl(newsId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetStoreNewsQueryKey = (newsId?: number,) => {
    return [
    `/api/store-news/${newsId}`
    ] as const;
    }

    
export const getGetStoreNewsQueryOptions = <TData = Awaited<ReturnType<typeof getStoreNews>>, TError = unknown>(newsId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNews>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStoreNewsQueryKey(newsId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoreNews>>> = ({ signal }) => getStoreNews(newsId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(newsId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStoreNews>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStoreNewsQueryResult = NonNullable<Awaited<ReturnType<typeof getStoreNews>>>
export type GetStoreNewsQueryError = unknown


export function useGetStoreNews<TData = Awaited<ReturnType<typeof getStoreNews>>, TError = unknown>(
 newsId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNews>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreNews>>,
          TError,
          Awaited<ReturnType<typeof getStoreNews>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStoreNews<TData = Awaited<ReturnType<typeof getStoreNews>>, TError = unknown>(
 newsId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNews>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreNews>>,
          TError,
          Awaited<ReturnType<typeof getStoreNews>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStoreNews<TData = Awaited<ReturnType<typeof getStoreNews>>, TError = unknown>(
 newsId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNews>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Í≥µÌÜµ] ÏÜåÏãù ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetStoreNews<TData = Awaited<ReturnType<typeof getStoreNews>>, TError = unknown>(
 newsId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreNews>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStoreNewsQueryOptions(newsId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * ÏÜåÏãùÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary [Ï†êÏ£º] ÏÜåÏãù ÏÇ≠Ï†ú
 */
export type deleteStoreNewsResponse200 = {
  data: CommonResponseVoid
  status: 200
}
    
export type deleteStoreNewsResponseSuccess = (deleteStoreNewsResponse200) & {
  headers: Headers;
};
;

export type deleteStoreNewsResponse = (deleteStoreNewsResponseSuccess)

export const getDeleteStoreNewsUrl = (newsId: number,) => {


  

  return `/api/store-news/${newsId}`
}

export const deleteStoreNews = async (newsId: number, options?: RequestInit): Promise<deleteStoreNewsResponse> => {
  
  return customFetch<deleteStoreNewsResponse>(getDeleteStoreNewsUrl(newsId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteStoreNewsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStoreNews>>, TError,{newsId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteStoreNews>>, TError,{newsId: number}, TContext> => {

const mutationKey = ['deleteStoreNews'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStoreNews>>, {newsId: number}> = (props) => {
          const {newsId} = props ?? {};

          return  deleteStoreNews(newsId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteStoreNewsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStoreNews>>>
    
    export type DeleteStoreNewsMutationError = unknown

    /**
 * @summary [Ï†êÏ£º] ÏÜåÏãù ÏÇ≠Ï†ú
 */
export const useDeleteStoreNews = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStoreNews>>, TError,{newsId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteStoreNews>>,
        TError,
        {newsId: number},
        TContext
      > => {
      return useMutation(getDeleteStoreNewsMutationOptions(options), queryClient);
    }
    /**
 * ÏÜåÏãùÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary [Ï†êÏ£º] ÏÜåÏãù ÏàòÏ†ï
 */
export type updateStoreNewsResponse200 = {
  data: CommonResponseVoid
  status: 200
}
    
export type updateStoreNewsResponseSuccess = (updateStoreNewsResponse200) & {
  headers: Headers;
};
;

export type updateStoreNewsResponse = (updateStoreNewsResponseSuccess)

export const getUpdateStoreNewsUrl = (newsId: number,) => {


  

  return `/api/store-news/${newsId}`
}

export const updateStoreNews = async (newsId: number,
    updateStoreNewsBody: UpdateStoreNewsBody, options?: RequestInit): Promise<updateStoreNewsResponse> => {
  
  return customFetch<updateStoreNewsResponse>(getUpdateStoreNewsUrl(newsId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateStoreNewsBody,)
  }
);}




export const getUpdateStoreNewsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStoreNews>>, TError,{newsId: number;data: UpdateStoreNewsBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateStoreNews>>, TError,{newsId: number;data: UpdateStoreNewsBody}, TContext> => {

const mutationKey = ['updateStoreNews'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStoreNews>>, {newsId: number;data: UpdateStoreNewsBody}> = (props) => {
          const {newsId,data} = props ?? {};

          return  updateStoreNews(newsId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateStoreNewsMutationResult = NonNullable<Awaited<ReturnType<typeof updateStoreNews>>>
    export type UpdateStoreNewsMutationBody = UpdateStoreNewsBody
    export type UpdateStoreNewsMutationError = unknown

    /**
 * @summary [Ï†êÏ£º] ÏÜåÏãù ÏàòÏ†ï
 */
export const useUpdateStoreNews = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStoreNews>>, TError,{newsId: number;data: UpdateStoreNewsBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateStoreNews>>,
        TError,
        {newsId: number;data: UpdateStoreNewsBody},
        TContext
      > => {
      return useMutation(getUpdateStoreNewsMutationOptions(options), queryClient);
    }
    /**
 * ÏûêÏã†Ïùò ÎåìÍ∏ÄÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÎåìÍ∏Ä ÏÇ≠Ï†ú
 */
export type deleteCommentResponse200 = {
  data: CommonResponseVoid
  status: 200
}
    
export type deleteCommentResponseSuccess = (deleteCommentResponse200) & {
  headers: Headers;
};
;

export type deleteCommentResponse = (deleteCommentResponseSuccess)

export const getDeleteCommentUrl = (newsId: number,
    commentId: number,) => {


  

  return `/api/store-news/${newsId}/comments/${commentId}`
}

export const deleteComment = async (newsId: number,
    commentId: number, options?: RequestInit): Promise<deleteCommentResponse> => {
  
  return customFetch<deleteCommentResponse>(getDeleteCommentUrl(newsId,commentId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteCommentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{newsId: number;commentId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{newsId: number;commentId: number}, TContext> => {

const mutationKey = ['deleteComment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteComment>>, {newsId: number;commentId: number}> = (props) => {
          const {newsId,commentId} = props ?? {};

          return  deleteComment(newsId,commentId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteComment>>>
    
    export type DeleteCommentMutationError = unknown

    /**
 * @summary [Í≥µÌÜµ] ÎåìÍ∏Ä ÏÇ≠Ï†ú
 */
export const useDeleteComment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{newsId: number;commentId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteComment>>,
        TError,
        {newsId: number;commentId: number},
        TContext
      > => {
      return useMutation(getDeleteCommentMutationOptions(options), queryClient);
    }
    