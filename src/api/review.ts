/**
 * Generated by orval v8.0.2 üç∫
 * Do not edit manually.
 * LOOKY API Server
 * API Î™ÖÏÑ∏ÏÑú
 * OpenAPI spec version: v1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateReviewBody,
  GetMyReviewsParams,
  GetReviewsParams,
  ReportRequest,
  UpdateReviewBody
} from './generated.schemas';

import { customFetch } from './mutator';



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * ÌäπÏ†ï ÏÉÅÏ†êÏùò Î¶¨Î∑∞ Î™©Î°ùÏùÑ ÌéòÏù¥ÏßïÌïòÏó¨ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÏÉÅÏ†ê Î¶¨Î∑∞ Î™©Î°ù Ï°∞Ìöå
 */
export type getReviewsResponse200 = {
  data: Blob
  status: 200
}

export type getReviewsResponse404 = {
  data: Blob
  status: 404
}
    
export type getReviewsResponseSuccess = (getReviewsResponse200) & {
  headers: Headers;
};
export type getReviewsResponseError = (getReviewsResponse404) & {
  headers: Headers;
};

export type getReviewsResponse = (getReviewsResponseSuccess | getReviewsResponseError)

export const getGetReviewsUrl = (storeId: number,
    params: GetReviewsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/stores/${storeId}/reviews?${stringifiedParams}` : `/api/stores/${storeId}/reviews`
}

export const getReviews = async (storeId: number,
    params: GetReviewsParams, options?: RequestInit): Promise<getReviewsResponse> => {
  
  return customFetch<getReviewsResponse>(getGetReviewsUrl(storeId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetReviewsQueryKey = (storeId?: number,
    params?: GetReviewsParams,) => {
    return [
    `/api/stores/${storeId}/reviews`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getReviews>>, TError = Blob>(storeId: number,
    params: GetReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviews>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewsQueryKey(storeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviews>>> = ({ signal }) => getReviews(storeId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(storeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviews>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getReviews>>>
export type GetReviewsQueryError = Blob


export function useGetReviews<TData = Awaited<ReturnType<typeof getReviews>>, TError = Blob>(
 storeId: number,
    params: GetReviewsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviews>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviews>>,
          TError,
          Awaited<ReturnType<typeof getReviews>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviews<TData = Awaited<ReturnType<typeof getReviews>>, TError = Blob>(
 storeId: number,
    params: GetReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviews>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviews>>,
          TError,
          Awaited<ReturnType<typeof getReviews>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviews<TData = Awaited<ReturnType<typeof getReviews>>, TError = Blob>(
 storeId: number,
    params: GetReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviews>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Í≥µÌÜµ] ÏÉÅÏ†ê Î¶¨Î∑∞ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetReviews<TData = Awaited<ReturnType<typeof getReviews>>, TError = Blob>(
 storeId: number,
    params: GetReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviews>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewsQueryOptions(storeId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * ÏÉÅÏ†êÏóê ÎåÄÌïú Î¶¨Î∑∞(ÌïôÏÉù) ÎòêÎäî ÎãµÍ∏Ä(Ï†êÏ£º, ÌïôÏÉù)ÏùÑ ÏûëÏÑ±Ìï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ Î∞è ÎãµÍ∏Ä ÏûëÏÑ±
 */
export type createReviewResponse201 = {
  data: Blob
  status: 201
}

export type createReviewResponse400 = {
  data: Blob
  status: 400
}

export type createReviewResponse403 = {
  data: Blob
  status: 403
}

export type createReviewResponse404 = {
  data: Blob
  status: 404
}

export type createReviewResponse409 = {
  data: Blob
  status: 409
}
    
export type createReviewResponseSuccess = (createReviewResponse201) & {
  headers: Headers;
};
export type createReviewResponseError = (createReviewResponse400 | createReviewResponse403 | createReviewResponse404 | createReviewResponse409) & {
  headers: Headers;
};

export type createReviewResponse = (createReviewResponseSuccess | createReviewResponseError)

export const getCreateReviewUrl = (storeId: number,) => {


  

  return `/api/stores/${storeId}/reviews`
}

export const createReview = async (storeId: number,
    createReviewBody: CreateReviewBody, options?: RequestInit): Promise<createReviewResponse> => {
    const formData = new FormData();
formData.append(`request`, JSON.stringify(createReviewBody.request));
if(createReviewBody.images !== undefined) {
 createReviewBody.images.forEach(value => formData.append(`images`, value));
 }

  return customFetch<createReviewResponse>(getCreateReviewUrl(storeId),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getCreateReviewMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{storeId: number;data: CreateReviewBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{storeId: number;data: CreateReviewBody}, TContext> => {

const mutationKey = ['createReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReview>>, {storeId: number;data: CreateReviewBody}> = (props) => {
          const {storeId,data} = props ?? {};

          return  createReview(storeId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof createReview>>>
    export type CreateReviewMutationBody = CreateReviewBody
    export type CreateReviewMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ Î∞è ÎãµÍ∏Ä ÏûëÏÑ±
 */
export const useCreateReview = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{storeId: number;data: CreateReviewBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createReview>>,
        TError,
        {storeId: number;data: CreateReviewBody},
        TContext
      > => {
      return useMutation(getCreateReviewMutationOptions(options), queryClient);
    }
    /**
 * ÌäπÏ†ï Î¶¨Î∑∞Î•º Ïã†Í≥†Ìï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ Ïã†Í≥† 
 */
export type reportReviewResponse200 = {
  data: Blob
  status: 200
}

export type reportReviewResponse404 = {
  data: Blob
  status: 404
}
    
export type reportReviewResponseSuccess = (reportReviewResponse200) & {
  headers: Headers;
};
export type reportReviewResponseError = (reportReviewResponse404) & {
  headers: Headers;
};

export type reportReviewResponse = (reportReviewResponseSuccess | reportReviewResponseError)

export const getReportReviewUrl = (reviewId: number,) => {


  

  return `/api/reviews/${reviewId}/reports`
}

export const reportReview = async (reviewId: number,
    reportRequest: ReportRequest, options?: RequestInit): Promise<reportReviewResponse> => {
  
  return customFetch<reportReviewResponse>(getReportReviewUrl(reviewId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      reportRequest,)
  }
);}




export const getReportReviewMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reportReview>>, TError,{reviewId: number;data: ReportRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof reportReview>>, TError,{reviewId: number;data: ReportRequest}, TContext> => {

const mutationKey = ['reportReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reportReview>>, {reviewId: number;data: ReportRequest}> = (props) => {
          const {reviewId,data} = props ?? {};

          return  reportReview(reviewId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ReportReviewMutationResult = NonNullable<Awaited<ReturnType<typeof reportReview>>>
    export type ReportReviewMutationBody = ReportRequest
    export type ReportReviewMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ Ïã†Í≥† 
 */
export const useReportReview = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reportReview>>, TError,{reviewId: number;data: ReportRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reportReview>>,
        TError,
        {reviewId: number;data: ReportRequest},
        TContext
      > => {
      return useMutation(getReportReviewMutationOptions(options), queryClient);
    }
    /**
 * Î¶¨Î∑∞Ïóê Ï¢ãÏïÑÏöîÎ•º ÎàÑÎ¶ÖÎãàÎã§.
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ Ï¢ãÏïÑÏöî
 */
export type addLikeResponse200 = {
  data: Blob
  status: 200
}

export type addLikeResponse400 = {
  data: Blob
  status: 400
}

export type addLikeResponse404 = {
  data: Blob
  status: 404
}

export type addLikeResponse409 = {
  data: Blob
  status: 409
}
    
export type addLikeResponseSuccess = (addLikeResponse200) & {
  headers: Headers;
};
export type addLikeResponseError = (addLikeResponse400 | addLikeResponse404 | addLikeResponse409) & {
  headers: Headers;
};

export type addLikeResponse = (addLikeResponseSuccess | addLikeResponseError)

export const getAddLikeUrl = (reviewId: number,) => {


  

  return `/api/reviews/${reviewId}/likes`
}

export const addLike = async (reviewId: number, options?: RequestInit): Promise<addLikeResponse> => {
  
  return customFetch<addLikeResponse>(getAddLikeUrl(reviewId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAddLikeMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addLike>>, TError,{reviewId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof addLike>>, TError,{reviewId: number}, TContext> => {

const mutationKey = ['addLike'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addLike>>, {reviewId: number}> = (props) => {
          const {reviewId} = props ?? {};

          return  addLike(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddLikeMutationResult = NonNullable<Awaited<ReturnType<typeof addLike>>>
    
    export type AddLikeMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ Ï¢ãÏïÑÏöî
 */
export const useAddLike = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addLike>>, TError,{reviewId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addLike>>,
        TError,
        {reviewId: number},
        TContext
      > => {
      return useMutation(getAddLikeMutationOptions(options), queryClient);
    }
    /**
 * Î¶¨Î∑∞ Ï¢ãÏïÑÏöîÎ•º Ï∑®ÏÜåÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export type removeLikeResponse200 = {
  data: Blob
  status: 200
}

export type removeLikeResponse404 = {
  data: Blob
  status: 404
}
    
export type removeLikeResponseSuccess = (removeLikeResponse200) & {
  headers: Headers;
};
export type removeLikeResponseError = (removeLikeResponse404) & {
  headers: Headers;
};

export type removeLikeResponse = (removeLikeResponseSuccess | removeLikeResponseError)

export const getRemoveLikeUrl = (reviewId: number,) => {


  

  return `/api/reviews/${reviewId}/likes`
}

export const removeLike = async (reviewId: number, options?: RequestInit): Promise<removeLikeResponse> => {
  
  return customFetch<removeLikeResponse>(getRemoveLikeUrl(reviewId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getRemoveLikeMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeLike>>, TError,{reviewId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof removeLike>>, TError,{reviewId: number}, TContext> => {

const mutationKey = ['removeLike'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeLike>>, {reviewId: number}> = (props) => {
          const {reviewId} = props ?? {};

          return  removeLike(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveLikeMutationResult = NonNullable<Awaited<ReturnType<typeof removeLike>>>
    
    export type RemoveLikeMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const useRemoveLike = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeLike>>, TError,{reviewId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeLike>>,
        TError,
        {reviewId: number},
        TContext
      > => {
      return useMutation(getRemoveLikeMutationOptions(options), queryClient);
    }
    /**
 * ÏûëÏÑ±Ìïú Î¶¨Î∑∞ ÎòêÎäî ÎãµÍ∏ÄÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§. (Î≥∏Ïù∏Îßå Í∞ÄÎä•)
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ ÏÇ≠Ï†ú
 */
export type deleteReviewResponse204 = {
  data: Blob
  status: 204
}

export type deleteReviewResponse403 = {
  data: Blob
  status: 403
}

export type deleteReviewResponse404 = {
  data: Blob
  status: 404
}
    
export type deleteReviewResponseSuccess = (deleteReviewResponse204) & {
  headers: Headers;
};
export type deleteReviewResponseError = (deleteReviewResponse403 | deleteReviewResponse404) & {
  headers: Headers;
};

export type deleteReviewResponse = (deleteReviewResponseSuccess | deleteReviewResponseError)

export const getDeleteReviewUrl = (reviewId: number,) => {


  

  return `/api/reviews/${reviewId}`
}

export const deleteReview = async (reviewId: number, options?: RequestInit): Promise<deleteReviewResponse> => {
  
  return customFetch<deleteReviewResponse>(getDeleteReviewUrl(reviewId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteReviewMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{reviewId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{reviewId: number}, TContext> => {

const mutationKey = ['deleteReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReview>>, {reviewId: number}> = (props) => {
          const {reviewId} = props ?? {};

          return  deleteReview(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteReviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReview>>>
    
    export type DeleteReviewMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ ÏÇ≠Ï†ú
 */
export const useDeleteReview = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{reviewId: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteReview>>,
        TError,
        {reviewId: number},
        TContext
      > => {
      return useMutation(getDeleteReviewMutationOptions(options), queryClient);
    }
    /**
 * ÏûëÏÑ±Ìïú Î¶¨Î∑∞ ÎòêÎäî ÎãµÍ∏ÄÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§. (Î≥∏Ïù∏Îßå Í∞ÄÎä•)
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ ÏàòÏ†ï
 */
export type updateReviewResponse200 = {
  data: Blob
  status: 200
}

export type updateReviewResponse403 = {
  data: Blob
  status: 403
}

export type updateReviewResponse404 = {
  data: Blob
  status: 404
}
    
export type updateReviewResponseSuccess = (updateReviewResponse200) & {
  headers: Headers;
};
export type updateReviewResponseError = (updateReviewResponse403 | updateReviewResponse404) & {
  headers: Headers;
};

export type updateReviewResponse = (updateReviewResponseSuccess | updateReviewResponseError)

export const getUpdateReviewUrl = (reviewId: number,) => {


  

  return `/api/reviews/${reviewId}`
}

export const updateReview = async (reviewId: number,
    updateReviewBody: UpdateReviewBody, options?: RequestInit): Promise<updateReviewResponse> => {
    const formData = new FormData();
formData.append(`request`, JSON.stringify(updateReviewBody.request));
if(updateReviewBody.images !== undefined) {
 updateReviewBody.images.forEach(value => formData.append(`images`, value));
 }

  return customFetch<updateReviewResponse>(getUpdateReviewUrl(reviewId),
  {      
    ...options,
    method: 'PATCH'
    ,
    body: 
      formData,
  }
);}




export const getUpdateReviewMutationOptions = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReview>>, TError,{reviewId: number;data: UpdateReviewBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateReview>>, TError,{reviewId: number;data: UpdateReviewBody}, TContext> => {

const mutationKey = ['updateReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateReview>>, {reviewId: number;data: UpdateReviewBody}> = (props) => {
          const {reviewId,data} = props ?? {};

          return  updateReview(reviewId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof updateReview>>>
    export type UpdateReviewMutationBody = UpdateReviewBody
    export type UpdateReviewMutationError = Blob

    /**
 * @summary [Í≥µÌÜµ] Î¶¨Î∑∞ ÏàòÏ†ï
 */
export const useUpdateReview = <TError = Blob,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReview>>, TError,{reviewId: number;data: UpdateReviewBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateReview>>,
        TError,
        {reviewId: number;data: UpdateReviewBody},
        TContext
      > => {
      return useMutation(getUpdateReviewMutationOptions(options), queryClient);
    }
    /**
 * ÏÉÅÏ†êÏùò ÌèâÏ†ê ÌèâÍ∑†, Ï¥ù Î¶¨Î∑∞ Ïàò, Î≥ÑÏ†êÎ≥Ñ Í∞úÏàò Î∂ÑÌè¨Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÏÉÅÏ†ê Î¶¨Î∑∞ ÌÜµÍ≥Ñ
 */
export type getReviewStatsResponse200 = {
  data: Blob
  status: 200
}

export type getReviewStatsResponse404 = {
  data: Blob
  status: 404
}
    
export type getReviewStatsResponseSuccess = (getReviewStatsResponse200) & {
  headers: Headers;
};
export type getReviewStatsResponseError = (getReviewStatsResponse404) & {
  headers: Headers;
};

export type getReviewStatsResponse = (getReviewStatsResponseSuccess | getReviewStatsResponseError)

export const getGetReviewStatsUrl = (storeId: number,) => {


  

  return `/api/stores/${storeId}/reviews/stats`
}

export const getReviewStats = async (storeId: number, options?: RequestInit): Promise<getReviewStatsResponse> => {
  
  return customFetch<getReviewStatsResponse>(getGetReviewStatsUrl(storeId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetReviewStatsQueryKey = (storeId?: number,) => {
    return [
    `/api/stores/${storeId}/reviews/stats`
    ] as const;
    }

    
export const getGetReviewStatsQueryOptions = <TData = Awaited<ReturnType<typeof getReviewStats>>, TError = Blob>(storeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewStatsQueryKey(storeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewStats>>> = ({ signal }) => getReviewStats(storeId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(storeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewStats>>>
export type GetReviewStatsQueryError = Blob


export function useGetReviewStats<TData = Awaited<ReturnType<typeof getReviewStats>>, TError = Blob>(
 storeId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewStats>>,
          TError,
          Awaited<ReturnType<typeof getReviewStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewStats<TData = Awaited<ReturnType<typeof getReviewStats>>, TError = Blob>(
 storeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewStats>>,
          TError,
          Awaited<ReturnType<typeof getReviewStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewStats<TData = Awaited<ReturnType<typeof getReviewStats>>, TError = Blob>(
 storeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Í≥µÌÜµ] ÏÉÅÏ†ê Î¶¨Î∑∞ ÌÜµÍ≥Ñ
 */

export function useGetReviewStats<TData = Awaited<ReturnType<typeof getReviewStats>>, TError = Blob>(
 storeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewStatsQueryOptions(storeId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * ÎÇ¥Í∞Ä ÏûëÏÑ±Ìïú Î¶¨Î∑∞ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [Í≥µÌÜµ] ÎÇ¥ Î¶¨Î∑∞ Î™©Î°ù Ï°∞Ìöå
 */
export type getMyReviewsResponse200 = {
  data: Blob
  status: 200
}
    
export type getMyReviewsResponseSuccess = (getMyReviewsResponse200) & {
  headers: Headers;
};
;

export type getMyReviewsResponse = (getMyReviewsResponseSuccess)

export const getGetMyReviewsUrl = (params: GetMyReviewsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/reviews/my?${stringifiedParams}` : `/api/reviews/my`
}

export const getMyReviews = async (params: GetMyReviewsParams, options?: RequestInit): Promise<getMyReviewsResponse> => {
  
  return customFetch<getMyReviewsResponse>(getGetMyReviewsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMyReviewsQueryKey = (params?: GetMyReviewsParams,) => {
    return [
    `/api/reviews/my`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetMyReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(params: GetMyReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyReviewsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyReviews>>> = ({ signal }) => getMyReviews(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMyReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyReviews>>>
export type GetMyReviewsQueryError = unknown


export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
 params: GetMyReviewsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
 params: GetMyReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
 params: GetMyReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary [Í≥µÌÜµ] ÎÇ¥ Î¶¨Î∑∞ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
 params: GetMyReviewsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMyReviewsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




